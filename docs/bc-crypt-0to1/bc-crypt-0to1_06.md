# 第六章 DES 算法

DES 算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是 1972 年美国 IBM 公司研制的对称密码体制加密算法，英文全称是 Data Encryption Standard。于 1973 年 5 月被美国采纳为联邦信息处理标准。该标准每 5 年审查一次。因为 DES 的安全性出现问题，同时 AES 的出现，美联邦在 1994 年 1 月取消了 DES 作为联邦加密标准。DES 加密不断被破解，其中用时最短的时间是 22 小时 15 分钟，所以 DES 算法现在应用越来越少了。
DES 是以 64 比特的明文为一个单位来进行加密的，超过 64 比特的数据，要求按固定的 64 比特的大小分组。每组 64 比特的明文加密得到同样长度的密文。DES 的密钥长度为 64 位。加密运算时实际用到的密钥长度是 56 位，原密钥舍弃掉 8 位比特，分别是每隔 8 位的比特，即原密钥的第 8 位，第 16 位，......，第 64 位。而舍弃掉的这 8 位比特作用是校验奇偶性的。这 8 个比特的定义如下：若其前面 7 个比特中有奇数个 1，则该比特为 0，反之为 1。

## 1\. DES 算法加密过程

DES 是一个迭代分组密码，在对明文加密之前先对明文进行补长，使补长后明文的比特长度模 64 为 0，再按照每组 64 比特分组。依次对分组密文进行加密，最终把加密后的结果拼接一起，得到密文。
每组 64 位的输入数据块 m 的加密过程如下：
1) 首先 m 经过初始置换 IP 得到 m[0] ；
2) 将 m[0]分成左右各为 32 比特两部分，记为 m[0] = L[0] R[0] ；
3) 对 L[0]和 R[0]进行 16 轮迭代运算加密，得到 L[16]和 R[16]；
4) 再对 L[16]R[16]进行初始置换 IP 的逆初始置换 IP^-1 ，得到该分组输入块的密文。
DES 加密总体框架如下图：
![](img/07e76d0266bdb1e3d59b6531657e9a30.jpg)

### 1.1 初始置换 IP

初始置换 IP 是将一个 64 比特的消息中的各个比特进行换位，目的是让消息中的各个比特的顺序错乱。设 m=m[1]m[2]...m[64]，根据初始置换 IP 表进行置换。初始置换 IP 表里的元素代表 m 的第几位。置换原则是按行依次对 m 的每个比特进行替换，比如 m[1]置换后是 m[58]，m[2]置换后是 m[50]，以此类推，最后的 m[64]置换后是 m[7]。经过置换后的分组明文块由两部分组成，记为 L[0]R[0]。

初始置换 IP 表：

| IP |
| --- |
| 58 50 42 34 26 18 10 2 |
| 60 52 44 36 28 20 12 4 |
| 62 54 46 38 30 22 14 6 |
| 64 56 48 40 32 24 16 8 |
| 57 49 41 33 25 17 9 1 |
| 59 51 43 35 27 19 11 3 |
| 61 53 45 37 29 21 13 5 |
| 63 55 47 39 31 23 15 7 |

### 1.2 16 轮迭代运算

迭代运算的结构是 Feistel。在 Feistel 结构中，加密的每个过程称为轮，全过程就是若干轮的加密运算。DES 第 16 轮加密运算与前 15 轮不一样，过程分为两步：1.和前 15 轮一样得到 L[16]和 R[16]；2.将得到的 L[16]和 R[16]两部分整体进行互换，得到最终的 L[16]R[16]。
每一轮的运算规则如下：
L[i] = R[i-1]
R[i] = L[i-1] ⊕ f(R[i-1] , k[i])
其中 L[0]和 R[0]已知；⊕表示两个比特串按位异或，f 是一个非线形函数，k[i]是由密钥按照一定规则每一轮生成的长度均为 48 位的比特串。
具体的迭代过程如下图所示：

![](img/33eb0183afd7f30cbaf80b2c889f5716.jpg)

迭代过程中最重要的内容是每轮子密钥 k[i]的生成和非线形函数 f。下面我们依次分析这两部分内容。

#### 1.2.1 子密钥 k[i]的生成

子密钥的生成是随着 f 函数的轮数顺序产生的。生成过程如下：
1） 给定一个 64 比特的初始密钥 k，利用置换 PC-1（表 1.2.1）得到 56 位密钥，然后将这 56 位密钥分成左右两部分，前 28 比特记为 C[0]，后 28 比特记为 D[0]。经过这次置换就会丢弃掉 8 位比特，这在 DES 的开始部分已经有解释。
2） 对于第 i 轮，1<=i<=16，首先计算
C[i]=LSi
D[i]=LSi
其中，LS[i]表示左循环移位，当 i=1，2，9，16 时，左循环移 1 位，当 i=3，4，5，6，7，8，10，11，12，13，14，15 时，左循环移位 2 位。
经过上边的左移位后，我们会得到当前 i 轮的 C[i]和 D[i]。
3） 将移位后的 C[i]和 D[i]利用 PC-2（表 1.2.2）置换，最终得到长度为 48 位的比特串，也就是子密钥。

具体过程的示意图如下：
![](img/8c52f5fc3aeaeaf40f6b436d6760a179.jpg)

表 1.2.1

| PC-1 |
| --- |
| 57 49 41 33 25 17 9 |
| 1 58 50 42 34 26 18 |
| 10 2 59 51 43 35 27 |
| 19 11 3 60 52 44 36 |
| 63 55 47 39 31 23 15 |
| 7 62 54 46 38 30 22 |
| 14 6 61 53 45 37 29 |
| 21 13 5 28 20 12 4 |

表 1.2.2

| PC-2 |
| --- |
| 14 17 11 24 1 5 |
| 3 28 15 6 21 10 |
| 23 19 12 4 26 8 |
| 16 7 27 20 13 2 |
| 41 52 31 37 47 55 |
| 30 40 51 45 33 48 |
| 44 49 39 56 34 53 |
| 46 42 50 36 29 32 |

#### 1.2.2 非线形函数 f

f 函数的参数有两个变量，一个是 32 比特的 R[i-1]，另一个是 48 比特的 k[i]，输出的结果为 32 比特。具体执行如下图：
![](img/dfd1cc64526f9d12762b954107e1bbcd.jpg)

过程是：

<1> R[i-1]是每轮迭代运算初始值的右半部分。它的长度为 32 位。通过扩展置换 E（表 1.2.3）扩展成一个 48 比特的串；
扩展置换 E 表里的数字都是 32 比特串的第几位。通过表可以看出 32 比特串分成 8 组，每组 4 位，然后将每组的 4 位前后根据表扩展，如第一组前面添加 32 比特串的第 32 位比特，后边添加 32 位比特串的第 5 位比特，其他依次类推。

<2> 48 比特的串与长度一致的 k[i]进行异或运算

<3> 将<2>步得到的 48 比特串分成 8 个 6 比特的串，即为 A[1]A[2]A[3]A[4]A[5]A[6]A[7]A[8]

<4> 将 A[1]，A[2]，A[3]，A[4]，A[5]，A[6]，A[7]，A[8]分别作为 8 个 S 盒的输入，查表（表 1.2.4）得到输出 B[1]，B[2]，B[3]，B[4]，B[5]，B[6]，B[7]，B[8]；
每个 S 盒都是将 6 比特消息映射成一个 4 比特的消息。设 S[i]盒的输入位 6 比特串 x=x[1]x[2]x[3]x[4]x[5]x[6]，将 x[1]x[6]转换成 10 进制的 0～3 的某个数，它对应表中的行数，将 x[2]x[3]x[4]x[5]转换成 0～15 的 10 进制的某个数，它作为表的列号，利用行号和列号查询对应 S 盒表得到一个整数，将该整数转换成二进制就是输出结果。例如 S[1]盒的输入是 110011，则行号是 11（第 3 行），列号是 1001（第 9 列），查表得到整数 11，再转换成二进制为 1011，这就是[1]盒的输出结果。

<5> 将 8 个 S 盒的输出拼接一起得到 B[1]B[2]B[3]B[4]B[5]B[6]B[7]B[8]，再将这 32 比特的串使用置换运算 P（表 1.2.5）得到最后的结果，也就是每轮函数 f 的输出。
置换运算 P：P 盒置换将每一位输入位映射到输出位。任何一位都不能被映射两次，也不能被略去。映射规则是，参照置换 P 表，将 32 位的输入的第 16 位放在第一位，第七位放在第二位，第二十位放在第三位，以此类推。

表 1.2.3
![](img/bd28e2aee4daf47bb4b9ff389d59d503.jpg)
备注：中间为 32 位，两侧为扩展位

表 1.2.4：
![](img/618e1a8653e1bb3c1b4fa13b4037cbef.jpg)

表 1.2.5：

| 置换 P |
| --- |
| 16,7,20,21,29,12,28,17,1,15,23,26,5,18,31,10 |
| 2,8,24,14,32,27,3,9,19,13,30,6,22,11,4,25 |

### 1.3 逆初始置换 IP^-1

逆置换是初始置换的逆运算。参照表 1.2.6，从初始置换规则中可以看到，原始数据的第 1 位置换到了第 40 位，第 2 位置换到了第 8 位。则逆置换就是将第 40 位置换到第 1 位，第 8 位置换到第 2 位。以此类推，逆置换规则如下。

表 1.2.6：

| 逆初始置换 IP^-1 |
| --- |
| 40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31 |
| 38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29 |
| 36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27 |
| 34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25 |

## 2 DES 算法解密过程

加密和解密使用相同的算法。加密和解密唯一不同的是秘钥的次序是相反的。就是说如果每一轮的加密秘钥分别是 K1、K2、K3...K16，那么解密秘钥就是 K16、K15、K14...K1。为每一轮产生秘钥的算法也是循环的。加密是秘钥循环左移，解密是秘钥循环右移。解密秘钥每次移动的位数是：0、1、2、2、2、2、2、2、1、2、2、2、2、2、2、1。具体不做讲解。但是要注意一点，解密的结果并不一定是我们原来的加密数据，可能还含有你补得位，一定要把补位去掉才是你的原来的数据。

## 3 DES 算法特点

1、分组加密算法：
以 64 位为分组。64 位明文输入，64 位密文输出。

2、对称算法：
加密和解密使用同一秘钥

3、有效密钥长度为 56 位
秘钥通常表示为 64 位数，但每个第 8 位用作奇偶校验，可以忽略。

4、代替和置换
DES 算法是两种加密技术的组合：混乱和扩散。先替代后置换。

5、易于实现
DES 算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有 64 位，因此用 70 年代末期的硬件技术很容易实现

## 4 golang 实现 DES_CBC 模式加解密

```go
package main

import (
    "crypto/cipher"//密码
    "crypto/des"
    "encoding/base64"//将对象转换成字符串
    "fmt"
    "bytes"
)

//DES 加密的方法
func MyDesEncrypt(origData,key[]byte)  {
  //生成加密块
    block,_:=des.NewCipher(key)
    //按照 blocksize 的长度 padding
    origData =PKCS5Padding(origData,des.BlockSize)
    //设置加密方式
    blockMode:=cipher.NewCBCEncrypter(block,key)
    //创建明文长度的字节数组
    crypted :=make([]byte,len(origData))
    //加密明文
    blockMode.CryptBlocks(crypted,origData)
    //将字节数组转换成字符串
    fmt.Println(base64.StdEncoding.EncodeToString(crypted))
}
//明文补码
func PKCS5Padding(ciphertext []byte,blockSize int) []byte {
    padding:=blockSize-len(ciphertext)%blockSize

    padtext := bytes.Repeat([]byte{byte(padding)},padding)//补码过程

    return append(ciphertext,padtext...)
}
//实现去补码
func PKCS5UnPadding(origData []byte)[]byte  {
    length:=len(origData)
    unpadding:=int(origData[length-1])
    return origData[:(length-unpadding)]
}
//DES 解密方法
func MyDESDecrypt(data string,key []byte)  {
    //将字符串转换成字节数组
     crypted,_:=base64.StdEncoding.DecodeString(data)
     //将字节密钥转换成 block 块
     block,_:=des.NewCipher(key)
     //设置解密方式
     blockMode:=cipher.NewCBCDecrypter(block,key)
     //创建秘文大小的数组变量
     origData:=make([]byte,len(crypted))
     //解密秘文到数组 origData 中
     blockMode.CryptBlocks(origData,crypted)
     origData=PKCS5UnPadding(origData)
     fmt.Println(string((origData)))
}
func main()  {
    fmt.Println("hello world")
    //声明一个密钥,利用此密钥实现明文的加密和解密
    key :=[]byte("12345698")
    MyDesEncrypt([]byte("hello world " ),key)
    MyDESDecrypt("NIJWb9F1DO11q08fSnB/HA==",key)
} 
```