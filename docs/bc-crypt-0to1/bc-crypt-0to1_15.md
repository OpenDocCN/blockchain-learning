# 第十五章 MD5 算法详解及 go 语言实现

MD5 英文全称 Message-Digest Algorithm，中文叫消息摘要算法。它是由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于 1992 年公开，用以取代被发现有安全缺陷的 MD4 算法。它是目前使用最广泛的密码学算法之一。

## 1 算法描述

MD5 算法将任意长度的消息进行函数运算，得到长度为 128 比特的 hash 值，该哈希值就是信息摘要。MD5 的算法是个单向函数，无法进行逆运算。单向函数的正运算速度快，安全性高，非常实用。目前 MD5 被广泛应用在防篡改、数字签名、安全访问认证等方面。

算法过程是将消息进行填充，之后按 512 比特一组进行分组，每组信息与初始向量的缓存值进行各种逻辑运算，迭代运算和压缩函数运算，最后得到的值就是 hash 值。

算法流程图如下：
![](img/24fd10906d58d7ef1c3a86e075dff7d9.jpg)

### 1\. 填充消息

填充消息使其长度与 448 模 512 同与（即长度≡448 mod 512）。也就是说，填充后的消息长度比 512 的某整数倍少 64 比特。填充的方法是：在消息后面进行填充，填充第一位为 1，其余为 0。注意，如果消息的长度刚好满足要求，也就是不填充消息，其长度与 448 模 512 同与。这种情况下也要进行填充操作，填充第一位为 1，剩余 511 位都是 0。

### 2\. 填充消息长度

完成第一步后，我们会发现如果再给消息填充 64 比特，那么消息的长度正好可以整除 512。那好，我们就把消息的长度转换成二进制填充到经过第一步处理的消息后边。如果消息的长度过于长，长度值大于 2⁶⁴ ，此时 64 位比特放不下这个长度值。如果这种情况，就取消息长度模 2⁶⁴ 的值作为填充的长度值。
在此步骤进行完毕后，最终消息长度就是 512 的整数倍。

### 3\. 初始化初始向量

定义 4 个 16 进制的大整数（这些突然冒出来的数也叫幻数） A=67452301；B=EFCDAB89；C=98BADCFE；D=10325476。

将这四个幻数以字节数组存储，也就是我们声明 4 个变量去存储这四个幻数。但是存储的类型有两种：小端法(Little-Endian)存储和大端法(Big-Endian)存储。小端法就是低位字节排放在内存的低地址端即该值的起始地址，高位字节排放在内存的高地址端。大端法(Big-Endian)就是高位字节排放在内存的低地址端即该值的起始地址，低位字节排放在内存的高地址端。

我们现在用这两种存储方法存储 A，来展示它们的区别：
小端法：A:=[]byte{01，23，45，67}
大端法：A:=[]byte{67，45，23，01}

MD5 算法的逻辑函数处理字节是从最低有效字节增大顺序处理的，所以要求大整数的存储需要小端法进行存储。
所以，代码中我们可以直接定义 4 个变量，并给予赋值，分别为了存储以上 4 个大数，变量如下：
A:=[]byte{01，23，45，67}
B:=[]byte{89，AB，CD，EF}
C:=[]byte{FE，DC，BA，98}
D:=[]byte{76，54，32，10}

变量的长度都为 4 个字节，也就是 32 比特，加在一起是 128，正好是最后 hash 值的长度。
这四个变量经过 MD5 函数处理后最终得到的结果拼接，就是最后的 hash 值。

### 4\. 以 512 比特的分组（16 个字）为单位处理消息

MD5 算法的核心就是压缩函数 H。每组消息的压缩由 4 轮运算完成，如图 4.1 所示。4 轮运算结构相同，但各轮使用的逻辑函数不同，分别是 H0，H1，H2，H3。每轮的输入为当前要处理的消息分组 Mq 和缓存区的当前 A、B、C、D，前 3 轮输出的 A、B、C、D 直接替换旧的并放在缓存区，最后一轮，也就是第四轮的输出 A、B、C、D 需要和第一轮的输入 A、B、C、D 进行模 2³² 加法运算之后再放到缓存区。这 4 轮的运算每轮都需要对缓存区 ABCD 进行 16 步迭代运算。

模加法运算很简单，其运算结果为两数相加后除以 n 的余数。模加法的数学符号是+。如 9 和 8 对 10 进行取模，结果是 7。

具体的分组信息压缩过程如下图：
![](img/9a18081f9478b0e6aefbef97bb7173e8.jpg)

### 5\. MD5 16 步迭代运算

压缩过程的每一轮都对缓冲区的 ABCD 进行 16 步的迭代运算，每一步的运算公式结构都是一样的，只是压缩函数不一样，我现在把 4 轮的压缩函数定义为 g，那么每轮的运算公式如下：
a=D
b=CLSs+X[k]+T[i])+B
c=B
d=C
其中 A，B，C，D 是缓存区中的 4 个字，a，b，c，d 是 A，B，C，D 压缩后对应的字，g 是基本逻辑函数 H0，H1，H2，H3 的对应一个，CLS[s]是 32 比特的变量循环左移 s 位，s 的取值如表 5.1 所示。X[k]=Y[q][q*16+k]，即消息的第 q 个分组中第 k 个字（k=0，...，15）。T[i]为表 T 中的第 i 个字，+为模 2³² 加法。

T 表：

|  | T 值 |
| --- | --- |
| 1 | 0xd76aa478 |
| 2 | 0xe8c7b756 |
| 3 | 0x242070db |
| 4 | 0xc1bdceee |
| 5 | 0xf57c0faf |
| 6 | 0x4787c62a |
| 7 | 0xa8304613 |
| 8 | 0xfd469501 |
| 9 | 0x698098d8 |
| 10 | 0x8b44f7af |
| 11 | 0xffff5bb1 |
| 12 | 0x895cd7be |
| 13 | 0x6b901122 |
| 14 | 0xfd987193 |
| 15 | 0xa679438e |
| 16 | 0x49b40821 |
| 17 | 0xf61e2562 |
| 18 | 0xc040b340 |
| 19 | 0x265e5a51 |
| 20 | 0xe9b6c7aa |
| 21 | 0xd62f105d |
| 22 | 0x02441453 |
| 23 | 0xd8a1e681 |
| 24 | 0xe7d3fbc8 |
| 25 | 0x21e1cde6 |
| 26 | 0xc33707d6 |
| 27 | 0xf4d50d87 |
| 28 | 0x455a14ed |
| 29 | 0xa9e3e905 |
| 30 | 0xfcefa3f8 |
| 31 | 0x676f02d9 |
| 32 | 0x8d2a4c8a |
| 33 | 0xfffa3942 |
| 34 | 0x8771f681 |
| 35 | 0x6d9d6122 |
| 36 | 0xfde5380c |
| 37 | 0xa4beea44 |
| 38 | 0x4bdecfa9 |
| 39 | 0xf6bb4b60 |
| 40 | 0xbebfbc70 |
| 41 | 0x289b7ec6 |
| 42 | 0xeaa127fa |
| 43 | 0xd4ef3085 |
| 44 | 0x04881d05 |
| 45 | 0xd9d4d039 |
| 46 | 0xe6db99e5 |
| 47 | 0x1fa27cf8 |
| 48 | 0xc4ac5665 |
| 49 | 0xf4292244 |
| 50 | 0x432aff97 |
| 51 | 0xab9423a7 |
| 52 | 0xfc93a039 |
| 53 | 0x655b59c3 |
| 54 | 0x8f0ccc92 |
| 55 | 0xffeff47d |
| 56 | 0x85845dd1 |
| 57 | 0x6fa87e4f |
| 58 | 0xfe2ce6e0 |
| 59 | 0xa3014314 |
| 60 | 0x4e0811a1 |
| 61 | 0xf7537e82 |
| 62 | 0xbd3af235 |
| 63 | 0x2ad7d2bb |
| 64 | 0xeb86d391 |

通过上边的公式我们得到了 a，b，c，d，将他们放到缓存区 A，B，C，D 进入下一步运算
运算示意图如下：
![](img/45b8e0801d08f89bc2161da11509683b.jpg)

表 5.1 压缩函数中每步循环左移位数表

|  | 步数 | 01 | 02 | 03 | 04 | 05 | 06 | 07 | 08 | 09 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 轮数 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| 1 |  | 7 | 12 | 17 | 22 | 7 | 12 | 17 | 22 | 7 | 12 | 17 | 22 | 7 | 12 | 17 | 22 |
| 2 |  | 5 | 9 | 14 | 20 | 5 | 9 | 14 | 20 | 5 | 9 | 14 | 20 | 5 | 9 | 14 | 20 |
| 3 |  | 4 | 11 | 16 | 23 | 4 | 11 | 16 | 23 | 4 | 11 | 16 | 23 | 4 | 11 | 16 | 23 |
| 4 |  | 6 | 10 | 15 | 21 | 6 | 10 | 15 | 21 | 6 | 10 | 15 | 21 | 6 | 10 | 15 | 21 |

g 逻辑函数每轮的表示：
第一轮：H0(B,C,D)=(B & C) | ((~B) & D)
第二轮：H1(B,C,D)=(B&D)|(C&(~D))
第三轮：H2(B,C,D)=B ^ C ^ D
第四轮：H3(B,C,D)=C ^ (B|~D)

上边公式里的运算符：
按位异或运算符" ^ "；按位或运算符"|"；按位与运算符"&"；按位取反运算符"~"。

对于 X[k]再做一下解释。当前要处理的 512 比特的分组消息保存在 Y[0...15]，其元素是一个 32 比特的字。每轮的 16 步运算每一步都是对 Y 里的某个元素进行处理。压缩是需要 4 轮进行的，但是每一轮对 Y 处理的次序是不一样的。
第一轮：顺序处理，k=k++
第二轮：k=（1+5i）mod 16
第三轮：k=（5+3i）mod 16
第四轮：k= 7i mod 16
其中 i 是 16 步运算的第 i 步。

## 2 用 goland 封装的方法使用 MD5

使用的方法和 sha256 类似

```go
package main

import(
    "fmt"
    "crypto/md5"
    "encoding/hex"
)

func main(){
    data := []byte("hello world")
    s := fmt.Sprintf("%x", md5.Sum(data))
    fmt.Println(s)

    // 也可以用这种方式
    h := md5.New()
    h.Write(data)
    s = hex.EncodeToString(h.Sum(nil))
    fmt.Println(s)
} 
```

## 3 Go 语言实现 MD5

```go
package main

import(
    "fmt"
    "unsafe"
)

const Size = 16

const (
    chunk = 64
    init0 = 0x67452301
    init1 = 0xEFCDAB89
    init2 = 0x98BADCFE
    init3 = 0x10325476
)

// digest represents the partial evaluation of a checksum.
type digest struct {
    s   [4]uint32
    x   [chunk]byte
    nx  int
    len uint64
}

func (d *digest) Reset() {
    d.s[0] = init0
    d.s[1] = init1
    d.s[2] = init2
    d.s[3] = init3
    d.nx = 0
    d.len = 0
}

func (d *digest) Write(p []byte) (nn int, err error) {
    nn = len(p)
    d.len += uint64(nn)
    if d.nx > 0 {
        n := copy(d.x[d.nx:], p)
        d.nx += n
        if d.nx == chunk {
            blockGeneric(d, d.x[:])
            d.nx = 0
        }
        p = p[n:]
    }
    if len(p) >= chunk {
        n := len(p) &^ (chunk - 1)
        blockGeneric(d, p[:n])
        p = p[n:]
    }
    if len(p) > 0 {
        d.nx = copy(d.x[:], p)
    }

    fmt.Printf("%v\n",d)

    return
}

func (d *digest) checkSum() [Size]byte {
    // Padding. Add a 1 bit and 0 bits until 56 bytes mod 64.
    len := d.len
    var tmp [64]byte
    tmp[0] = 0x80
    if len%64 < 56 {
        d.Write(tmp[0 : 56-len%64])
        fmt.Printf("%v",d)
    } else {
        d.Write(tmp[0 : 64+56-len%64])
    }

    // Length in bits.
    len <<= 3
    for i := uint(0); i < 8; i++ {
        tmp[i] = byte(len >> (8 * i))
    }
    d.Write(tmp[0:8])

    if d.nx != 0 {
        panic("d.nx != 0")
    }

    var digest [Size]byte
    for i, s := range d.s {
        digest[i*4] = byte(s)
        digest[i*4+1] = byte(s >> 8)
        digest[i*4+2] = byte(s >> 16)
        digest[i*4+3] = byte(s >> 24)
    }

    return digest
}

func blockGeneric(dig *digest, p []byte) {
    a := dig.s[0]
    b := dig.s[1]
    c := dig.s[2]
    d := dig.s[3]
    var X *[16]uint32
    for len(p) >= chunk {
        aa, bb, cc, dd := a, b, c, d

        X = (*[16]uint32)(unsafe.Pointer(&p[0]))

        // Round 1.

        a += (((c ^ d) & b) ^ d) + X[0] + 3614090360
        a = a<<7 | a>>(32-7) + b

        d += (((b ^ c) & a) ^ c) + X[1] + 3905402710
        d = d<<12 | d>>(32-12) + a

        c += (((a ^ b) & d) ^ b) + X[2] + 606105819
        c = c<<17 | c>>(32-17) + d

        b += (((d ^ a) & c) ^ a) + X[3] + 3250441966
        b = b<<22 | b>>(32-22) + c

        a += (((c ^ d) & b) ^ d) + X[4] + 4118548399
        a = a<<7 | a>>(32-7) + b

        d += (((b ^ c) & a) ^ c) + X[5] + 1200080426
        d = d<<12 | d>>(32-12) + a

        c += (((a ^ b) & d) ^ b) + X[6] + 2821735955
        c = c<<17 | c>>(32-17) + d

        b += (((d ^ a) & c) ^ a) + X[7] + 4249261313
        b = b<<22 | b>>(32-22) + c

        a += (((c ^ d) & b) ^ d) + X[8] + 1770035416
        a = a<<7 | a>>(32-7) + b

        d += (((b ^ c) & a) ^ c) + X[9] + 2336552879
        d = d<<12 | d>>(32-12) + a

        c += (((a ^ b) & d) ^ b) + X[10] + 4294925233
        c = c<<17 | c>>(32-17) + d

        b += (((d ^ a) & c) ^ a) + X[11] + 2304563134
        b = b<<22 | b>>(32-22) + c

        a += (((c ^ d) & b) ^ d) + X[12] + 1804603682
        a = a<<7 | a>>(32-7) + b

        d += (((b ^ c) & a) ^ c) + X[13] + 4254626195
        d = d<<12 | d>>(32-12) + a

        c += (((a ^ b) & d) ^ b) + X[14] + 2792965006
        c = c<<17 | c>>(32-17) + d

        b += (((d ^ a) & c) ^ a) + X[15] + 1236535329
        b = b<<22 | b>>(32-22) + c

        // Round 2.

        a += (((b ^ c) & d) ^ c) + X[(1+5*0)&15] + 4129170786
        a = a<<5 | a>>(32-5) + b

        d += (((a ^ b) & c) ^ b) + X[(1+5*1)&15] + 3225465664
        d = d<<9 | d>>(32-9) + a

        c += (((d ^ a) & b) ^ a) + X[(1+5*2)&15] + 643717713
        c = c<<14 | c>>(32-14) + d

        b += (((c ^ d) & a) ^ d) + X[(1+5*3)&15] + 3921069994
        b = b<<20 | b>>(32-20) + c

        a += (((b ^ c) & d) ^ c) + X[(1+5*4)&15] + 3593408605
        a = a<<5 | a>>(32-5) + b

        d += (((a ^ b) & c) ^ b) + X[(1+5*5)&15] + 38016083
        d = d<<9 | d>>(32-9) + a

        c += (((d ^ a) & b) ^ a) + X[(1+5*6)&15] + 3634488961
        c = c<<14 | c>>(32-14) + d

        b += (((c ^ d) & a) ^ d) + X[(1+5*7)&15] + 3889429448
        b = b<<20 | b>>(32-20) + c

        a += (((b ^ c) & d) ^ c) + X[(1+5*8)&15] + 568446438
        a = a<<5 | a>>(32-5) + b

        d += (((a ^ b) & c) ^ b) + X[(1+5*9)&15] + 3275163606
        d = d<<9 | d>>(32-9) + a

        c += (((d ^ a) & b) ^ a) + X[(1+5*10)&15] + 4107603335
        c = c<<14 | c>>(32-14) + d

        b += (((c ^ d) & a) ^ d) + X[(1+5*11)&15] + 1163531501
        b = b<<20 | b>>(32-20) + c

        a += (((b ^ c) & d) ^ c) + X[(1+5*12)&15] + 2850285829
        a = a<<5 | a>>(32-5) + b

        d += (((a ^ b) & c) ^ b) + X[(1+5*13)&15] + 4243563512
        d = d<<9 | d>>(32-9) + a

        c += (((d ^ a) & b) ^ a) + X[(1+5*14)&15] + 1735328473
        c = c<<14 | c>>(32-14) + d

        b += (((c ^ d) & a) ^ d) + X[(1+5*15)&15] + 2368359562
        b = b<<20 | b>>(32-20) + c

        // Round 3.

        a += (b ^ c ^ d) + X[(5+3*0)&15] + 4294588738
        a = a<<4 | a>>(32-4) + b

        d += (a ^ b ^ c) + X[(5+3*1)&15] + 2272392833
        d = d<<11 | d>>(32-11) + a

        c += (d ^ a ^ b) + X[(5+3*2)&15] + 1839030562
        c = c<<16 | c>>(32-16) + d

        b += (c ^ d ^ a) + X[(5+3*3)&15] + 4259657740
        b = b<<23 | b>>(32-23) + c

        a += (b ^ c ^ d) + X[(5+3*4)&15] + 2763975236
        a = a<<4 | a>>(32-4) + b

        d += (a ^ b ^ c) + X[(5+3*5)&15] + 1272893353
        d = d<<11 | d>>(32-11) + a

        c += (d ^ a ^ b) + X[(5+3*6)&15] + 4139469664
        c = c<<16 | c>>(32-16) + d

        b += (c ^ d ^ a) + X[(5+3*7)&15] + 3200236656
        b = b<<23 | b>>(32-23) + c

        a += (b ^ c ^ d) + X[(5+3*8)&15] + 681279174
        a = a<<4 | a>>(32-4) + b

        d += (a ^ b ^ c) + X[(5+3*9)&15] + 3936430074
        d = d<<11 | d>>(32-11) + a

        c += (d ^ a ^ b) + X[(5+3*10)&15] + 3572445317
        c = c<<16 | c>>(32-16) + d

        b += (c ^ d ^ a) + X[(5+3*11)&15] + 76029189
        b = b<<23 | b>>(32-23) + c

        a += (b ^ c ^ d) + X[(5+3*12)&15] + 3654602809
        a = a<<4 | a>>(32-4) + b

        d += (a ^ b ^ c) + X[(5+3*13)&15] + 3873151461
        d = d<<11 | d>>(32-11) + a

        c += (d ^ a ^ b) + X[(5+3*14)&15] + 530742520
        c = c<<16 | c>>(32-16) + d

        b += (c ^ d ^ a) + X[(5+3*15)&15] + 3299628645
        b = b<<23 | b>>(32-23) + c

        // Round 4.

        a += (c ^ (b | ^d)) + X[(7*0)&15] + 4096336452
        a = a<<6 | a>>(32-6) + b

        d += (b ^ (a | ^c)) + X[(7*1)&15] + 1126891415
        d = d<<10 | d>>(32-10) + a

        c += (a ^ (d | ^b)) + X[(7*2)&15] + 2878612391
        c = c<<15 | c>>(32-15) + d

        b += (d ^ (c | ^a)) + X[(7*3)&15] + 4237533241
        b = b<<21 | b>>(32-21) + c

        a += (c ^ (b | ^d)) + X[(7*4)&15] + 1700485571
        a = a<<6 | a>>(32-6) + b

        d += (b ^ (a | ^c)) + X[(7*5)&15] + 2399980690
        d = d<<10 | d>>(32-10) + a

        c += (a ^ (d | ^b)) + X[(7*6)&15] + 4293915773
        c = c<<15 | c>>(32-15) + d

        b += (d ^ (c | ^a)) + X[(7*7)&15] + 2240044497
        b = b<<21 | b>>(32-21) + c

        a += (c ^ (b | ^d)) + X[(7*8)&15] + 1873313359
        a = a<<6 | a>>(32-6) + b

        d += (b ^ (a | ^c)) + X[(7*9)&15] + 4264355552
        d = d<<10 | d>>(32-10) + a

        c += (a ^ (d | ^b)) + X[(7*10)&15] + 2734768916
        c = c<<15 | c>>(32-15) + d

        b += (d ^ (c | ^a)) + X[(7*11)&15] + 1309151649
        b = b<<21 | b>>(32-21) + c

        a += (c ^ (b | ^d)) + X[(7*12)&15] + 4149444226
        a = a<<6 | a>>(32-6) + b

        d += (b ^ (a | ^c)) + X[(7*13)&15] + 3174756917
        d = d<<10 | d>>(32-10) + a

        c += (a ^ (d | ^b)) + X[(7*14)&15] + 718787259
        c = c<<15 | c>>(32-15) + d

        b += (d ^ (c | ^a)) + X[(7*15)&15] + 3951481745
        b = b<<21 | b>>(32-21) + c

        a += aa
        b += bb
        c += cc
        d += dd

        p = p[chunk:]
    }

    dig.s[0] = a
    dig.s[1] = b
    dig.s[2] = c
    dig.s[3] = d
}

func main() {
    var d digest
    d.Reset()
    data := []byte("hello world")

    d.Write(data)

    hashnum := d.checkSum()

    fmt.Printf("%x\n",hashnum)

} 
```